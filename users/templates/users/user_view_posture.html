{% extends 'index.html' %}
{% block head %}
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.1/control_utils.js"
    crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.2/drawing_utils.js"
    crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.2/pose.js" crossorigin="anonymous"></script>
{% endblock %}
{% block body %}
<div class="container mt-5">
    <div class="row">
        {% for posture in postures %}
        <div class="col-xl-3 col-md-6 mb-4">
            <div class="card border-left-success shadow h-100 py-2">
                <div class="card-body">
                    <div class="row no-gutters align-items-center">
                        <div class="col mr-2">
                            <div class="font-weight-bold text-primary mb-1">
                                {{posture.name}}</div>
                            <div class="mb-0 font-weight-bold text-gray-800">{% if posture.dataset %} Trained {% else %}
                                Not Trained {% endif %}</div>
                        </div>
                        <div class="col-auto">
                            <a href="#" onclick="loadTest({{posture.id}})">
                                <div class="col-auto">
                                    <i class="fas fa-arrow-right fa-2x text-gray-300"></i>
                                </div>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        {% endfor%}
    </div>
    <video class="input_video5" style="display:none;"></video>
    <div id="train" class="card shadow mb-4 mt-4" style="display:none;">
        <div class="card-header py-3">
            <h6 class="m-0 font-weight-bold text-primary">KnowInMy - Test</h6>
        </div>
        <div class="card-body">
            <div class="row">
                <div class="col-4">
                    <canvas class="output5" width="480px" height="480px"></canvas>
                </div>
                <div class="col-2"></div>
                <div class="col-6" id="snapshot">
                </div>
            </div>
        </div>
    </div>
    <div style="visibility: hidden;" class="control5"></div>
</div>
<script>
    var array
    var snap_shot;
    async function loadTest(posture_id) {
        response = await fetch(`/get_posture_dataset?posture_id=${posture_id}`)
        response = await response.json()
        array = await response["dataset"]
        console.log(await array)
        snap_shot = await response["snapshot"]
        await tester()
    }
    function tester() {
        document.getElementById("train").style.display = "block";
        document.getElementById("train").scrollIntoView({ behavior: "smooth" })
        const out5 = document.getElementsByClassName('output5')[0];
        const controlsElement5 = document.getElementsByClassName('control5')[0];
        const video5 = document.getElementsByClassName('input_video5')[0];
        const canvasCtx5 = out5.getContext('2d');
        const pi = Math.PI
        const fpsControl = new FPS();
        var score = 0
        var isBegin = false
        snapshot = document.getElementById("snapshot")
        canvasCtx5.font = "30px Comic Sans MS";
        canvasCtx5.fillStyle = "red";

        function zColor(data) {
            const z = clamp(data.from.z + 0.5, 0, 1);
            return `rgba(0, ${255 * z}, ${255 * (1 - z)}, 1)`;
        }

        function calculateAngle(landmark1, landmark2, landmark3) {
            angle = (Math.atan2(landmark3.y - landmark2.y, landmark3.x - landmark2.x) - Math.atan2(landmark1.y - landmark2.y, landmark1.x - landmark2.x)) * (180 / pi)
            if (angle < 0) {
                angle *= -1
            }
            if (angle > 180) {
                angle = 360 - angle
            }
            return Math.round(angle)
        }

        function onResultsPose(results) {
            fpsControl.tick();
            canvasCtx5.save();
            canvasCtx5.clearRect(0, 0, out5.width, out5.height);
            canvasCtx5.font = "30px Arial";
            canvasCtx5.fillText(score,10,50);
            canvasCtx5.drawImage(
                results.image, 0, 0, out5.width, out5.height);
            drawConnectors(
                canvasCtx5, results.poseLandmarks, POSE_CONNECTIONS, {
                color:"#FF0000"
            });
            drawConnectors(
                canvasCtx5, [results.poseLandmarks[11],results.poseLandmarks[12]], POSE_CONNECTIONS, {
                color:"#00FF00"
            });

            //since here the frame is flipped left will be right and right will be left
            // to get the index value refer the https://mediapipe.dev/images/mobile/pose_tracking_full_body_landmarks.png
            // 11 which means left shoulder, since here it is flipped 11 means right shoulder
            left_hand_elbow = calculateAngle(results.poseLandmarks[12], results.poseLandmarks[14], results.poseLandmarks[16])
            right_hand_elbow = calculateAngle(results.poseLandmarks[11], results.poseLandmarks[13], results.poseLandmarks[15])
            left_shoulder = calculateAngle(results.poseLandmarks[14], results.poseLandmarks[12], results.poseLandmarks[24])
            right_shoulder = calculateAngle(results.poseLandmarks[13], results.poseLandmarks[11], results.poseLandmarks[23])
            left_hip = calculateAngle(results.poseLandmarks[12], results.poseLandmarks[24], results.poseLandmarks[26])
            right_hip = calculateAngle(results.poseLandmarks[11], results.poseLandmarks[23], results.poseLandmarks[25])
            left_knee = calculateAngle(results.poseLandmarks[24], results.poseLandmarks[26], results.poseLandmarks[28])
            right_knee = calculateAngle(results.poseLandmarks[23], results.poseLandmarks[25], results.poseLandmarks[27])
            left_wrist_cordinate = Math.round(results.poseLandmarks[16].x * out5.width)
            right_wrist_cordinate = Math.round(results.poseLandmarks[15].x * out5.width)
            two_hand_distance = Math.abs(right_wrist_cordinate - left_wrist_cordinate)
            calculated = [two_hand_distance, left_hand_elbow, right_hand_elbow, left_shoulder,right_shoulder, left_hip, right_hip, left_knee, right_knee]
            connector_points = {
                0:[],
                1:[results.poseLandmarks[11],results.poseLandmarks[13],results.poseLandmarks[15]],
                2:[results.poseLandmarks[12],results.poseLandmarks[14],results.poseLandmarks[16]],
                3:[results.poseLandmarks[11],results.poseLandmarks[13],results.poseLandmarks[23]],
                4:[results.poseLandmarks[12],results.poseLandmarks[14],results.poseLandmarks[24]],
                5:[results.poseLandmarks[11],results.poseLandmarks[23],results.poseLandmarks[25]],
                6:[results.poseLandmarks[12],results.poseLandmarks[24],results.poseLandmarks[26]],
                7:[results.poseLandmarks[23],results.poseLandmarks[25],results.poseLandmarks[27]],
                8:[results.poseLandmarks[24],results.poseLandmarks[26],results.poseLandmarks[28]]
            }
            checker = []
            green = []

            if (isBegin){ 
                for(i=0;i<array.length;i++){
                    if (array[i].includes(calculated[i])){
                        checker.push(true)
                        green.push(connector_points[i])  
                    }    
                    else{
                        checker.push(false)
                        break
                    }
                }
                if (checker.every(check => check === true)){
                    score += 1
                }
                canvasCtx5.fillText(score, out5.width - 50,25);
                for(i=0;i<green.length;i++){
                    drawConnectors(
                    canvasCtx5, green[i], POSE_CONNECTIONS, {
                    color: "#00FF00"
                    });
                }
                
            }
            else{
                canvasCtx5.fillText("Get Reddy !!", out5.width - 200,25);
            }
            if (score == 150) {
                const stream = video5.srcObject;
                const tracks = stream.getTracks();
                tracks.forEach((track) => {
                    track.stop();
                });
                document.getElementById("train").style.display = "none"
            }
            drawLandmarks(
                canvasCtx5,
                Object.values(POSE_LANDMARKS_LEFT)
                    .map(index => results.poseLandmarks[index]),
                { color: zColor, fillColor: '#FF0000' });
            drawLandmarks(
                canvasCtx5,
                Object.values(POSE_LANDMARKS_RIGHT)
                    .map(index => results.poseLandmarks[index]),
                { color: zColor, fillColor: '#00FF00' });
            drawLandmarks(
                canvasCtx5,
                Object.values(POSE_LANDMARKS_NEUTRAL)
                    .map(index => results.poseLandmarks[index]),
                { color: zColor, fillColor: '#AAAAAA' });
            canvasCtx5.restore();
        }

        const pose = new Pose({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.2/${file}`;
            }
        });
        pose.onResults(onResultsPose);

        const camera = new Camera(video5, {
            onFrame: async () => {
                await pose.send({ image: video5 });
            },
            width: 480,
            height: 480
        });
        camera.start();

        new ControlPanel(controlsElement5, {
            selfieMode: true,
            upperBodyOnly: false,
            smoothLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5,
        })
            .add([
                new StaticText({ title: 'MediaPipe Pose' }),
                fpsControl,
                new Toggle({ title: 'Selfie Mode', field: 'selfieMode' }),
                new Toggle({ title: 'Upper-body Only', field: 'upperBodyOnly' }),
                new Toggle({ title: 'Smooth Landmarks', field: 'smoothLandmarks' }),
                new Slider({
                    title: 'Min Detection Confidence',
                    field: 'minDetectionConfidence',
                    range: [0, 1],
                    step: 0.01
                }),
                new Slider({
                    title: 'Min Tracking Confidence',
                    field: 'minTrackingConfidence',
                    range: [0, 1],
                    step: 0.01
                }),
            ])
            .on(options => {
                video5.classList.toggle('selfie', options.selfieMode);
                pose.setOptions(options);
            });
        snapshot.innerHTML = `<img src=${snap_shot} id="snap" width="480px" height="480px">`
        setTimeout(() => {
            count = 3
            canvasCtx5.font = "30px Comic Sans MS";
            canvasCtx5.fillStyle = "red";
            const myinterval = setInterval(()=>{

                if(count == 0){
                    isBegin = true
                    clearInterval(myinterval)
                }
                canvasCtx5.fillText(count, out5.width - 50,25);
                count -= 1
            },1000)

            
        },10000)
    }
</script>
{% endblock %}